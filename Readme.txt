<<Бинарное дерево>>

Бинарное дерево - это структура данных, каждый элемент которой имеет 2 потомка.
Левый и Правый.

Элемент дерева
    Element
----------------
=              =
=    Data      =
=              =
=--------------=
=pLeft = pRight=
----------------

В левом потомке содержится значение меньше текущего элемента, а в правом потомке большего текущего элемента.
У бинарного дерева, как и у другого любого дерева есть корень.(root). А если дерево пустое, то его корень указывает на 0.

Root
[*]
 |
 |
 V
 0


                                                   Идеально сбалансированное бинарное дерево
                                                            (Perfect Binary Three)
                                                                      Root
                                                                      [*]   
                                                                       |
                                                                       |
                                                                       V
                                                                       0
                                                                ----------------
                                                                =              =
                                                                =      50      =
                                                                =              =
                                                                =--------------=
                                                                =pLeft = pRight=
                                                                /--------------\
                                                               /                \
                                                              /                  \
                                                             /                    \
                                                            /                      \
                                                           /                        \
                                                          /                          \
                                                         /                            \
                                                        /                              \
                                                       /                                \
                                                      /                                  \
                                                     /                                    \
                                                    /                                      \
                                    ----------------                                        ----------------
                                    =              =                                        =              =
                                    =      25      =                                        =      80      =
                                    =              =                                        =              =
                                    =--------------=                                        =--------------=
                                    =pLeft = pRight=                                        =pLeft = pRight=
                                    /--------------\                                        /--------------\
                                   /                \                                      /                \
                   ----------------                 ----------------       ----------------                  ----------------
                   =              =                 =              =       =              =                  =              =
                   =      16      =                 =      32      =       =      64      =                  =      96      =
                   =              =                 =              =       =              =                  =              =
                   =--------------=                 =--------------=       =--------------=                  =--------------=
                   =pLeft = pRight=                 =pLeft = pRight=       =pLeft = pRight=                  =pLeft = pRight=
                   ----------------                 ----------------       ----------------                  ----------------





В идеально сбалансированном бинарном дереве - Количество узлов на каждой длинне в два раза больше предыдущего.
Следовательно количество узлов на заданной глубине можно определить по формуле n = 2^h.
В идеально сбалансированном бинарном дереве - У каждого узла в определённом порядке обязательно есть 2 потомка или вообще нет потомков.
В идеально сбалансированном бинарном дереве - из тысячи элементов нужное значение можно найти за 10 шагов, 
также при переходе на каждую глубину значение уменьшается в 2 раза.

Если дерево заполнить отсортированной последовательностью, то оно будет выражденным (Degenerate Three).
Выражденное бинарное дерево напоминает односвязный список.

Существуют две возможные реализации бинарного дерева: Рекурсивная и Итерационная.

При Итерационной реализации У каждого элемента Кроме указателей
на потомков, также должен быть указатель на родительский элемент.

В рекурсивной же Реализации адрес родительского элемента хранится
в стеке рекурсивных вызовов и нет необходимости постоянно хранить его
в каждом элементе.






// Отплыли от темы ~~повторение

Рекурсией называется ситуация при которой функция вызывает саму себя,
непосредственно или через другую функцию.

Рекурсия нужна для организации циклических действий и большинство
задач можно решить как итерационно - при помощи циклов,
так и рекурсивно.

Некоторые задачи удобно решать итерационно, а некоторые рекурсивно.
В отличии от циклов, которые могут быть бесконечными, рекурсия 
бесконечной быть не может, поскольку для каждого вызова функции
затрачиваются ресурсы памяти, а именно ресурсы стека.
Как раз в стеке сохраняется текущее состояние вызывающей функции(Caller).
Как раз через стек передаются параметры в вызываемую функцию.(Callee)

При рекурсии вызовов может быть сотни, тысячи, сотни тысяч, 
что очень сильно нагружает стек, если рекурсивные вызовы не
контроллировать, то стек рано или поздно будет переполнен,
при этом возникает исключительная ситуация.
(Stack overflow exception) происходит аварийное завершение программы.

Prog.exe
-----------------------
=                     =
=    Code segment     = В сегмент кода загружаются команды процессора 
=                     = (mov,add,......)
-----------------------
=                     =
=    Data segment     =
=                     =
-----------------------
=                     =
=    Stack segment    =
=                     =
-----------------------

Размер стека определяется при компановки программы и его можно задать
 в настройках линкера.

При рекурсии, вызываемой и вызывающей является одна и та же функция.
С прототипом, реализацией и вызовом функции, но особое место в рекурсии
имеет как раз вызов функции.

Каждый вызов сохраняется в стеке вызовов и то что сохранено в стеке,
всегда можно оттуда достать.

При написании рекурсивной функции, в первую очередь нужно подумать об
условиях выхода из рекурсии.
